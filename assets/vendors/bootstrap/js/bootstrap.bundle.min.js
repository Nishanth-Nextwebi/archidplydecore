!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t() }(this, function () { "use strict"; const j = "transitionend", H = t => { let i = t.getAttribute("data-bs-target"); if (!i || "#" === i) { let e = t.getAttribute("href"); if (!e || !e.includes("#") && !e.startsWith(".")) return null; e.includes("#") && !e.startsWith("#") && (e = "#" + e.split("#")[1]), i = e && "#" !== e ? e.trim() : null } return i }, W = e => (e = H(e)) && document.querySelector(e) ? e : null, s = e => (e = H(e)) ? document.querySelector(e) : null, B = e => { e.dispatchEvent(new Event(j)) }, o = e => !(!e || "object" != typeof e) && void 0 !== (e = void 0 !== e.jquery ? e[0] : e).nodeType, n = e => o(e) ? e.jquery ? e[0] : e : "string" == typeof e && 0 < e.length ? document.querySelector(e) : null, r = e => { if (!o(e) || 0 === e.getClientRects().length) return !1; var t = "visible" === getComputedStyle(e).getPropertyValue("visibility"), i = e.closest("details:not([open])"); if (i && i !== e) { if ((e = e.closest("summary")) && e.parentNode !== i) return !1; if (null === e) return !1 } return t }, a = e => !e || e.nodeType !== Node.ELEMENT_NODE || !!e.classList.contains("disabled") || (void 0 !== e.disabled ? e.disabled : e.hasAttribute("disabled") && "false" !== e.getAttribute("disabled")), F = e => { var t; return document.documentElement.attachShadow ? "function" == typeof e.getRootNode ? (t = e.getRootNode()) instanceof ShadowRoot ? t : null : e instanceof ShadowRoot ? e : e.parentNode ? F(e.parentNode) : null : null }, z = () => { }, R = e => { e.offsetHeight }, q = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, V = [], l = () => "rtl" === document.documentElement.dir; var e = n => { var e = () => { const e = q(); if (e) { const t = n.NAME, i = e.fn[t]; e.fn[t] = n.jQueryInterface, e.fn[t].Constructor = n, e.fn[t].noConflict = () => (e.fn[t] = i, n.jQueryInterface) } }; "loading" === document.readyState ? (V.length || document.addEventListener("DOMContentLoaded", () => { for (const e of V) e() }), V.push(e)) : e() }; const c = e => { "function" == typeof e && e() }, $ = (i, s, e = !0) => { if (e) { e = (e => { if (!s) return 0; let { transitionDuration: t, transitionDelay: i } = window.getComputedStyle(s); var e = Number.parseFloat(t), n = Number.parseFloat(i); return e || n ? (t = t.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(i))) : 0 })() + 5; let t = !1; const n = ({ target: e }) => { e === s && (t = !0, s.removeEventListener(j, n), c(i)) }; s.addEventListener(j, n), setTimeout(() => { t || B(s) }, e) } else c(i) }, K = (e, t, i, n) => { var s = e.length; let o = e.indexOf(t); return -1 === o ? !i && n ? e[s - 1] : e[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), e[Math.max(0, Math.min(o, s - 1))]) }, Q = /[^.]*(?=\..*)\.|.*/, X = /\..*/, Y = /::\d+$/, U = {}; let G = 1; const J = { mouseenter: "mouseover", mouseleave: "mouseout" }, Z = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function ee(e, t) { return t && t + "::" + G++ || e.uidEvent || G++ } function te(e) { var t = ee(e); return e.uidEvent = t, U[t] = U[t] || {}, U[t] } function ie(e, t, i = null) { return Object.values(e).find(e => e.originalHandler === t && e.delegationSelector === i) } function ne(e, t, i) { var n = "string" == typeof t, i = n ? i : t, t = re(e); return [n, i, Z.has(t) ? t : e] } function se(e, t, i, n, s) { var o, r, a, l, c, h, d, u, f, p; "string" == typeof t && e && ([o, r, a] = (i || (i = n, n = null), t in J && (o = t => function (e) { if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e) }, n ? n = o(n) : i = o(i)), ne(t, i, n)), (c = ie(l = (l = te(e))[a] || (l[a] = {}), r, o ? i : null)) ? c.oneOff = c.oneOff && s : (c = ee(r, t.replace(Q, "")), (t = o ? (u = e, f = i, p = n, function t(i) { var n = u.querySelectorAll(f); for (let e = i.target; e && e !== this; e = e.parentNode)for (const s of n) if (s === e) return i.delegateTarget = e, t.oneOff && g.off(u, i.type, f, p), p.apply(e, [i]) }) : (h = e, d = i, function e(t) { return t.delegateTarget = h, e.oneOff && g.off(h, t.type, d), d.apply(h, [t]) })).delegationSelector = o ? i : null, t.originalHandler = r, t.oneOff = s, l[t.uidEvent = c] = t, e.addEventListener(a, t, o))) } function oe(e, t, i, n, s) { (n = ie(t[i], n, s)) && (e.removeEventListener(i, n, Boolean(s)), delete t[i][n.uidEvent]) } function re(e) { return e = e.replace(X, ""), J[e] || e } const g = { on(e, t, i, n) { se(e, t, i, n, !1) }, one(e, t, i, n) { se(e, t, i, n, !0) }, off(e, t, i, n) { if ("string" == typeof t && e) { var [n, s, o] = ne(t, i, n), r = o !== t, a = te(e), l = t.startsWith("."); if (void 0 !== s) return a && a[o] ? void oe(e, a, o, s, n ? i : null) : void 0; if (l) for (const _ of Object.keys(a)) { var c, h = e, d = a, u = _, f = t.slice(1), p = d[u] || {}; for (const b of Object.keys(p)) b.includes(f) && oe(h, d, u, (c = p[b]).originalHandler, c.delegationSelector) } var g = a[o] || {}; for (const v of Object.keys(g)) { var m = v.replace(Y, ""); r && !t.includes(m) || oe(e, a, o, (m = g[v]).originalHandler, m.delegationSelector) } } }, trigger(e, t, i) { if ("string" != typeof t || !e) return null; var n = q(); let s = null, o = !0, r = !0, a = !1; t !== re(t) && n && (s = n.Event(t, i), n(e).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented()); var l = new Event(t, { bubbles: o, cancelable: !0 }); if (void 0 !== i) for (const c of Object.keys(i)) Object.defineProperty(l, c, { get() { return i[c] } }); return a && l.preventDefault(), r && e.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l } }, h = new Map, ae = { set(e, t, i) { h.has(e) || h.set(e, new Map), (e = h.get(e)).has(t) || 0 === e.size ? e.set(t, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(e.keys())[0]}.`) }, get(e, t) { return h.has(e) && h.get(e).get(t) || null }, remove(e, t) { var i; h.has(e) && ((i = h.get(e)).delete(t), 0 === i.size) && h.delete(e) } }; function le(t) { if ("true" === t) return !0; if ("false" === t) return !1; if (t === Number(t).toString()) return Number(t); if ("" === t || "null" === t) return null; if ("string" != typeof t) return t; try { return JSON.parse(decodeURIComponent(t)) } catch (e) { return t } } function ce(e) { return e.replace(/[A-Z]/g, e => "-" + e.toLowerCase()) } const d = { setDataAttribute(e, t, i) { e.setAttribute("data-bs-" + ce(t), i) }, removeDataAttribute(e, t) { e.removeAttribute("data-bs-" + ce(t)) }, getDataAttributes(t) { if (!t) return {}; var i = {}; for (const n of Object.keys(t.dataset).filter(e => e.startsWith("bs") && !e.startsWith("bsConfig"))) { let e = n.replace(/^bs/, ""); i[e = e.charAt(0).toLowerCase() + e.slice(1, e.length)] = le(t.dataset[n]) } return i }, getDataAttribute(e, t) { return le(e.getAttribute("data-bs-" + ce(t))) } }; class he { static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } _getConfig(e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e } _mergeConfigObj(e, t) { var i = o(t) ? d.getDataAttribute(t, "config") : {}; return { ...this.constructor.Default, ..."object" == typeof i ? i : {}, ...o(t) ? d.getDataAttributes(t) : {}, ..."object" == typeof e ? e : {} } } _typeCheckConfig(e, t = this.constructor.DefaultType) { for (const s of Object.keys(t)) { var i = t[s], n = e[s], n = o(n) ? "element" : null == n ? "" + n : Object.prototype.toString.call(n).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(i).test(n)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${n}" but expected type "${i}".`) } } } class t extends he { constructor(e, t) { super(), (e = n(e)) && (this._element = e, this._config = this._getConfig(t), ae.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { ae.remove(this._element, this.constructor.DATA_KEY), g.off(this._element, this.constructor.EVENT_KEY); for (const e of Object.getOwnPropertyNames(this)) this[e] = null } _queueCallback(e, t, i = !0) { $(e, t, i) } _getConfig(e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } static getInstance(e) { return ae.get(n(e), this.DATA_KEY) } static getOrCreateInstance(e, t = {}) { return this.getInstance(e) || new this(e, "object" == typeof t ? t : null) } static get VERSION() { return "5.2.0-beta1" } static get DATA_KEY() { return "bs." + this.NAME } static get EVENT_KEY() { return "." + this.DATA_KEY } static eventName(e) { return "" + e + this.EVENT_KEY } } var de = (t, i = "hide") => { var e = "click.dismiss" + t.EVENT_KEY; const n = t.NAME; g.on(document, e, `[data-bs-dismiss="${n}"]`, function (e) { ["A", "AREA"].includes(this.tagName) && e.preventDefault(), a(this) || (e = s(this) || this.closest("." + n), t.getOrCreateInstance(e)[i]()) }) }; class ue extends t { static get NAME() { return "alert" } close() { var e; g.trigger(this._element, "close.bs.alert").defaultPrevented || (this._element.classList.remove("show"), e = this._element.classList.contains("fade"), this._queueCallback(() => this._destroyElement(), this._element, e)) } _destroyElement() { this._element.remove(), g.trigger(this._element, "closed.bs.alert"), this.dispose() } static jQueryInterface(t) { return this.each(function () { var e = ue.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } }) } } de(ue, "close"), e(ue); const fe = '[data-bs-toggle="button"]'; class pe extends t { static get NAME() { return "button" } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle("active")) } static jQueryInterface(t) { return this.each(function () { var e = pe.getOrCreateInstance(this); "toggle" === t && e[t]() }) } } g.on(document, "click.bs.button.data-api", fe, e => { e.preventDefault(), e = e.target.closest(fe), pe.getOrCreateInstance(e).toggle() }), e(pe); const u = { find(e, t = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(t, e)) }, findOne(e, t = document.documentElement) { return Element.prototype.querySelector.call(t, e) }, children(e, t) { return [].concat(...e.children).filter(e => e.matches(t)) }, parents(e, t) { var i = []; let n = e.parentNode.closest(t); for (; n;)i.push(n), n = n.parentNode.closest(t); return i }, prev(e, t) { let i = e.previousElementSibling; for (; i;) { if (i.matches(t)) return [i]; i = i.previousElementSibling } return [] }, next(e, t) { let i = e.nextElementSibling; for (; i;) { if (i.matches(t)) return [i]; i = i.nextElementSibling } return [] }, focusableChildren(e) { var t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(e => e + ':not([tabindex^="-"])').join(","); return this.find(t, e).filter(e => !a(e) && r(e)) } }, i = ".bs.swipe", ge = (i, i, i, i, i, { leftCallback: null, rightCallback: null, endCallback: null }), me = { leftCallback: "(function|null)", rightCallback: "(function|null)", endCallback: "(function|null)" }; class _e extends he { constructor(e, t) { super(), (this._element = e) && _e.isSupported() && (this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()) } static get Default() { return ge } static get DefaultType() { return me } static get NAME() { return "swipe" } dispose() { g.off(this._element, i) } _start(e) { this._supportPointerEvents ? this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) : this._deltaX = e.touches[0].clientX } _end(e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), c(this._config.endCallback) } _move(e) { this._deltaX = e.touches && 1 < e.touches.length ? 0 : e.touches[0].clientX - this._deltaX } _handleSwipe() { var e = Math.abs(this._deltaX); e <= 40 || (e /= this._deltaX, this._deltaX = 0, e && c(0 < e ? this._config.rightCallback : this._config.leftCallback)) } _initEvents() { this._supportPointerEvents ? (g.on(this._element, "pointerdown.bs.swipe", e => this._start(e)), g.on(this._element, "pointerup.bs.swipe", e => this._end(e)), this._element.classList.add("pointer-event")) : (g.on(this._element, "touchstart.bs.swipe", e => this._start(e)), g.on(this._element, "touchmove.bs.swipe", e => this._move(e)), g.on(this._element, "touchend.bs.swipe", e => this._end(e))) } _eventIsPointerPenTouch(e) { return this._supportPointerEvents && ("pen" === e.pointerType || "touch" === e.pointerType) } static isSupported() { return "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints } } const be = "next", f = "prev", p = "left", ve = "right", ye = "slid.bs.carousel", we = "carousel", Ae = "active", Ee = ".active", Te = ".carousel-item", Ce = (Ee, Te, { ArrowLeft: ve, ArrowRight: p }), Oe = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 }, xe = { interval: "(number|boolean)", keyboard: "boolean", ride: "(boolean|string)", pause: "(string|boolean)", touch: "boolean", wrap: "boolean" }; class ke extends t { constructor(e, t) { super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = u.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === we && this.cycle() } static get Default() { return Oe } static get DefaultType() { return xe } static get NAME() { return "carousel" } next() { this._slide(be) } nextWhenVisible() { !document.hidden && r(this._element) && this.next() } prev() { this._slide(f) } pause() { this._isSliding && B(this._element), this._clearInterval() } cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval) } _maybeEnableCycle() { this._config.ride && (this._isSliding ? g.one(this._element, ye, () => this.cycle()) : this.cycle()) } to(e) { var t, i = this._getItems(); e > i.length - 1 || e < 0 || (this._isSliding ? g.one(this._element, ye, () => this.to(e)) : (t = this._getItemIndex(this._getActive())) !== e && (t = t < e ? be : f, this._slide(t, i[e]))) } dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() } _configAfterMerge(e) { return e.defaultInterval = e.interval, e } _addEventListeners() { this._config.keyboard && g.on(this._element, "keydown.bs.carousel", e => this._keydown(e)), "hover" === this._config.pause && (g.on(this._element, "mouseenter.bs.carousel", () => this.pause()), g.on(this._element, "mouseleave.bs.carousel", () => this._maybeEnableCycle())), this._config.touch && _e.isSupported() && this._addTouchEventListeners() } _addTouchEventListeners() { for (const t of u.find(".carousel-item img", this._element)) g.on(t, "dragstart.bs.carousel", e => e.preventDefault()); var e = { leftCallback: () => this._slide(this._directionToOrder(p)), rightCallback: () => this._slide(this._directionToOrder(ve)), endCallback: () => { "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval)) } }; this._swipeHelper = new _e(this._element, e) } _keydown(e) { var t; /input|textarea/i.test(e.target.tagName) || (t = Ce[e.key]) && (e.preventDefault(), this._slide(this._directionToOrder(t))) } _getItemIndex(e) { return this._getItems().indexOf(e) } _setActiveIndicatorElement(e) { var t; this._indicatorsElement && ((t = u.findOne(Ee, this._indicatorsElement)).classList.remove(Ae), t.removeAttribute("aria-current"), t = u.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement)) && (t.classList.add(Ae), t.setAttribute("aria-current", "true")) } _updateInterval() { var e = this._activeElement || this._getActive(); e && (e = Number.parseInt(e.getAttribute("data-bs-interval"), 10), this._config.interval = e || this._config.defaultInterval) } _slide(t, e = null) { if (!this._isSliding) { const n = this._getActive(); var i = t === be; const s = e || K(this._getItems(), n, i, this._config.wrap); if (s !== n) { const o = this._getItemIndex(s), r = e => g.trigger(this._element, e, { relatedTarget: s, direction: this._orderToDirection(t), from: this._getItemIndex(n), to: o }); if (!(e = r("slide.bs.carousel")).defaultPrevented && n && s) { e = Boolean(this._interval), this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s; const a = i ? "carousel-item-start" : "carousel-item-end", l = i ? "carousel-item-next" : "carousel-item-prev"; s.classList.add(l), R(s), n.classList.add(a), s.classList.add(a), this._queueCallback(() => { s.classList.remove(a, l), s.classList.add(Ae), n.classList.remove(Ae, l, a), this._isSliding = !1, r(ye) }, n, this._isAnimated()), e && this.cycle() } } } } _isAnimated() { return this._element.classList.contains("slide") } _getActive() { return u.findOne(".active.carousel-item", this._element) } _getItems() { return u.find(Te, this._element) } _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) } _directionToOrder(e) { return l() ? e === p ? f : be : e === p ? be : f } _orderToDirection(e) { return l() ? e === f ? p : ve : e === f ? ve : p } static jQueryInterface(t) { return this.each(function () { var e = ke.getOrCreateInstance(this, t); if ("number" == typeof t) e.to(t); else if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } }) } } g.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", function (e) { var t = s(this); t && t.classList.contains(we) && (e.preventDefault(), e = ke.getOrCreateInstance(t), (t = this.getAttribute("data-bs-slide-to")) ? e.to(t) : "next" === d.getDataAttribute(this, "slide") ? e.next() : e.prev(), e._maybeEnableCycle()) }), g.on(window, "load.bs.carousel.data-api", () => { for (const e of u.find('[data-bs-ride="carousel"]')) ke.getOrCreateInstance(e) }), e(ke); const Le = "show", m = "collapse", De = "collapsing", Se = (m, m, '[data-bs-toggle="collapse"]'), Ie = { toggle: !0, parent: null }, Ne = { toggle: "boolean", parent: "(null|element)" }; class Pe extends t { constructor(e, t) { super(e, t), this._isTransitioning = !1, this._triggerArray = []; for (const s of u.find(Se)) { var i = W(s), n = u.find(i).filter(e => e === this._element); null !== i && n.length && this._triggerArray.push(s) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return Ie } static get DefaultType() { return Ne } static get NAME() { return "collapse" } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (!this._isTransitioning && !this._isShown()) { var e = []; if (!(e = this._config.parent ? this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(e => e !== this._element).map(e => Pe.getOrCreateInstance(e, { toggle: !1 })) : e).length || !e[0]._isTransitioning) if (!g.trigger(this._element, "show.bs.collapse").defaultPrevented) { for (const i of e) i.hide(); const t = this._getDimension(); this._element.classList.remove(m), this._element.classList.add(De), this._element.style[t] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0, e = "scroll" + (t[0].toUpperCase() + t.slice(1)), this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove(De), this._element.classList.add(m, Le), this._element.style[t] = "", g.trigger(this._element, "shown.bs.collapse") }, this._element, !0), this._element.style[t] = this._element[e] + "px" } } } hide() { var e; if (!this._isTransitioning && this._isShown() && !g.trigger(this._element, "hide.bs.collapse").defaultPrevented) { e = this._getDimension(), this._element.style[e] = this._element.getBoundingClientRect()[e] + "px", R(this._element), this._element.classList.add(De), this._element.classList.remove(m, Le); for (const i of this._triggerArray) { var t = s(i); t && !this._isShown(t) && this._addAriaAndCollapsedClass([i], !1) } this._isTransitioning = !0, this._element.style[e] = "", this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove(De), this._element.classList.add(m), g.trigger(this._element, "hidden.bs.collapse") }, this._element, !0) } } _isShown(e = this._element) { return e.classList.contains(Le) } _configAfterMerge(e) { return e.toggle = Boolean(e.toggle), e.parent = n(e.parent), e } _getDimension() { return this._element.classList.contains("collapse-horizontal") ? "width" : "height" } _initializeChildren() { if (this._config.parent) for (const t of this._getFirstLevelChildren(Se)) { var e = s(t); e && this._addAriaAndCollapsedClass([t], this._isShown(e)) } } _getFirstLevelChildren(e) { const t = u.find(":scope .collapse .collapse", this._config.parent); return u.find(e, this._config.parent).filter(e => !t.includes(e)) } _addAriaAndCollapsedClass(e, t) { if (e.length) for (const i of e) i.classList.toggle("collapsed", !t), i.setAttribute("aria-expanded", t) } static jQueryInterface(t) { const i = {}; return "string" == typeof t && /show|hide/.test(t) && (i.toggle = !1), this.each(function () { var e = Pe.getOrCreateInstance(this, i); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } }) } } g.on(document, "click.bs.collapse.data-api", Se, function (e) { ("A" === e.target.tagName || e.delegateTarget && "A" === e.delegateTarget.tagName) && e.preventDefault(), e = W(this); for (const t of u.find(e)) Pe.getOrCreateInstance(t, { toggle: !1 }).toggle() }), e(Pe); var Me, x = "top", k = "bottom", L = "right", D = "left", je = "auto", S = [x, k, L, D], I = "start", v = "end", He = "clippingParents", We = "viewport", _ = "popper", Be = "reference", Fe = S.reduce(function (e, t) { return e.concat([t + "-" + I, t + "-" + v]) }, []), ze = [].concat(S, [je]).reduce(function (e, t) { return e.concat([t, t + "-" + I, t + "-" + v]) }, []), Re = "afterRead", qe = "beforeMain", Ve = "afterMain", $e = "beforeWrite", Ke = "afterWrite", Qe = [Me = "beforeRead", "read", Re, qe, "main", Ve, $e, "write", Ke]; function b(e) { return e ? (e.nodeName || "").toLowerCase() : null } function y(e) { var t; return null == e ? window : "[object Window]" !== e.toString() ? (t = e.ownerDocument) && t.defaultView || window : e } function Xe(e) { return e instanceof y(e).Element || e instanceof Element } function w(e) { return e instanceof y(e).HTMLElement || e instanceof HTMLElement } function Ye(e) { return "undefined" != typeof ShadowRoot && (e instanceof y(e).ShadowRoot || e instanceof ShadowRoot) } var Ue = { name: "applyStyles", enabled: !0, phase: "write", fn: function (e) { var s = e.state; Object.keys(s.elements).forEach(function (e) { var t = s.styles[e] || {}, i = s.attributes[e] || {}, n = s.elements[e]; w(n) && b(n) && (Object.assign(n.style, t), Object.keys(i).forEach(function (e) { var t = i[e]; !1 === t ? n.removeAttribute(e) : n.setAttribute(e, !0 === t ? "" : t) })) }) }, effect: function (e) { var n = e.state, s = { popper: { position: n.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(n.elements.popper.style, s.popper), n.styles = s, n.elements.arrow && Object.assign(n.elements.arrow.style, s.arrow), function () { Object.keys(n.elements).forEach(function (e) { var t = n.elements[e], i = n.attributes[e] || {}, e = Object.keys((n.styles.hasOwnProperty(e) ? n.styles : s)[e]).reduce(function (e, t) { return e[t] = "", e }, {}); w(t) && b(t) && (Object.assign(t.style, e), Object.keys(i).forEach(function (e) { t.removeAttribute(e) })) }) } }, requires: ["computeStyles"] }; function N(e) { return e.split("-")[0] } var O = Math.max, Ge = Math.min, Je = Math.round; function Ze(e, t) { void 0 === t && (t = !1); var i = e.getBoundingClientRect(), n = 1, s = 1; return w(e) && t && (t = e.offsetHeight, 0 < (e = e.offsetWidth) && (n = Je(i.width) / e || 1), 0 < t) && (s = Je(i.height) / t || 1), { width: i.width / n, height: i.height / s, top: i.top / s, right: i.right / n, bottom: i.bottom / s, left: i.left / n, x: i.left / n, y: i.top / s } } function et(e) { var t = Ze(e), i = e.offsetWidth, n = e.offsetHeight; return Math.abs(t.width - i) <= 1 && (i = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), { x: e.offsetLeft, y: e.offsetTop, width: i, height: n } } function tt(e, t) { var i = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (i && Ye(i)) { var n = t; do { if (n && e.isSameNode(n)) return !0 } while (n = n.parentNode || n.host) } return !1 } function A(e) { return y(e).getComputedStyle(e) } function E(e) { return ((Xe(e) ? e.ownerDocument : e.document) || window.document).documentElement } function it(e) { return "html" === b(e) ? e : e.assignedSlot || e.parentNode || (Ye(e) ? e.host : null) || E(e) } function nt(e) { return w(e) && "fixed" !== A(e).position ? e.offsetParent : null } function st(e) { for (var t, i = y(e), n = nt(e); n && (t = n, 0 <= ["table", "td", "th"].indexOf(b(t))) && "static" === A(n).position;)n = nt(n); return (!n || "html" !== b(n) && ("body" !== b(n) || "static" !== A(n).position)) && (n || function (e) { var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"); if (!(-1 !== navigator.userAgent.indexOf("Trident")) || !w(e) || "fixed" !== A(e).position) { var i = it(e); for (Ye(i) && (i = i.host); w(i) && ["html", "body"].indexOf(b(i)) < 0;) { var n = A(i); if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || t && "filter" === n.willChange || t && n.filter && "none" !== n.filter) return i; i = i.parentNode } } return null }(e)) || i } function ot(e) { return 0 <= ["top", "bottom"].indexOf(e) ? "x" : "y" } function rt(e, t, i) { return O(e, Ge(t, i)) } function at() { return { top: 0, right: 0, bottom: 0, left: 0 } } function lt(e) { return Object.assign({}, at(), e) } function ct(i, e) { return e.reduce(function (e, t) { return e[t] = i, e }, {}) } var ht = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, i, n, s, o = e.state, r = e.name, e = e.options, a = o.elements.arrow, l = o.modifiersData.popperOffsets, c = ot(h = N(o.placement)), h = 0 <= [D, L].indexOf(h) ? "height" : "width"; a && l && (i = lt("number" != typeof (e = "function" == typeof (e = e.padding) ? e(Object.assign({}, o.rects, { placement: o.placement })) : e) ? e : ct(e, S)), e = et(a), s = "y" === c ? x : D, n = "y" === c ? k : L, t = o.rects.reference[h] + o.rects.reference[c] - l[c] - o.rects.popper[h], l = l[c] - o.rects.reference[c], a = (a = st(a)) ? "y" === c ? a.clientHeight || 0 : a.clientWidth || 0 : 0, s = i[s], i = a - e[h] - i[n], s = rt(s, n = a / 2 - e[h] / 2 + (t / 2 - l / 2), i), o.modifiersData[r] = ((a = {})[c] = s, a.centerOffset = s - n, a)) }, effect: function (e) { var t = e.state; null != (e = void 0 === (e = e.options.element) ? "[data-popper-arrow]" : e) && ("string" != typeof e || (e = t.elements.popper.querySelector(e))) && tt(t.elements.popper, e) && (t.elements.arrow = e) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function dt(e) { return e.split("-")[1] } var ut = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function ft(e) { var t, i, n, s = e.popper, o = e.popperRect, r = e.placement, a = e.variation, l = e.offsets, c = e.position, h = e.gpuAcceleration, d = e.adaptive, u = e.roundOffsets, e = e.isFixed, f = void 0 === (f = l.x) ? 0 : f, p = void 0 === (p = l.y) ? 0 : p, g = (f = (g = "function" == typeof u ? u({ x: f, y: p }) : { x: f, y: p }).x, p = g.y, l.hasOwnProperty("x")), l = l.hasOwnProperty("y"), m = D, _ = x, b = window, s = (d && (i = "clientHeight", t = "clientWidth", (n = st(s)) === y(s) && "static" !== A(n = E(s)).position && "absolute" === c && (i = "scrollHeight", t = "scrollWidth"), r !== x && (r !== D && r !== L || a !== v) || (_ = k, p = (p - ((e && n === b && b.visualViewport ? b.visualViewport.height : n[i]) - o.height)) * (h ? 1 : -1)), r !== D && (r !== x && r !== k || a !== v) || (m = L, f = (f - ((e && n === b && b.visualViewport ? b.visualViewport.width : n[t]) - o.width)) * (h ? 1 : -1))), Object.assign({ position: c }, d && ut)); return f = (e = !0 === u ? (r = (i = { x: f, y: p }).x, i = i.y, a = window.devicePixelRatio || 1, { x: Je(r * a) / a || 0, y: Je(i * a) / a || 0 }) : { x: f, y: p }).x, p = e.y, h ? Object.assign({}, s, ((n = {})[_] = l ? "0" : "", n[m] = g ? "0" : "", n.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + p + "px)" : "translate3d(" + f + "px, " + p + "px, 0)", n)) : Object.assign({}, s, ((t = {})[_] = l ? p + "px" : "", t[m] = g ? f + "px" : "", t.transform = "", t)) } var pt = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, i = void 0 === (i = (e = e.options).gpuAcceleration) || i, n = void 0 === (n = e.adaptive) || n, e = void 0 === (e = e.roundOffsets) || e, i = { placement: N(t.placement), variation: dt(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: i, isFixed: "fixed" === t.options.strategy }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, ft(Object.assign({}, i, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: n, roundOffsets: e })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, ft(Object.assign({}, i, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: e })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }, gt = { passive: !0 }, mt = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, i = e.instance, n = (e = e.options).scroll, s = void 0 === n || n, o = void 0 === (n = e.resize) || n, r = y(t.elements.popper), a = [].concat(t.scrollParents.reference, t.scrollParents.popper); return s && a.forEach(function (e) { e.addEventListener("scroll", i.update, gt) }), o && r.addEventListener("resize", i.update, gt), function () { s && a.forEach(function (e) { e.removeEventListener("scroll", i.update, gt) }), o && r.removeEventListener("resize", i.update, gt) } }, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" }; function bt(e) { return e.replace(/left|right|bottom|top/g, function (e) { return _t[e] }) } var vt = { start: "end", end: "start" }; function yt(e) { return e.replace(/start|end/g, function (e) { return vt[e] }) } function wt(e) { return { scrollLeft: (e = y(e)).pageXOffset, scrollTop: e.pageYOffset } } function At(e) { return Ze(E(e)).left + wt(e).scrollLeft } function Et(e) { var t = (e = A(e)).overflow, i = e.overflowX, e = e.overflowY; return /auto|scroll|overlay|hidden/.test(t + e + i) } function Tt(e, t) { void 0 === t && (t = []); var e = (n = function e(t) { return 0 <= ["html", "body", "#document"].indexOf(b(t)) ? t.ownerDocument.body : w(t) && Et(t) ? t : e(it(t)) }(e)) === (null == (e = e.ownerDocument) ? void 0 : e.body), i = y(n), i = e ? [i].concat(i.visualViewport || [], Et(n) ? n : []) : n, n = t.concat(i); return e ? n : n.concat(Tt(it(i))) } function Ct(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Ot(e, t) { return t === We ? Ct((n = y(i = e), s = E(i), n = n.visualViewport, o = s.clientWidth, s = s.clientHeight, a = r = 0, n && (o = n.width, s = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = n.offsetLeft, a = n.offsetTop)), { width: o, height: s, x: r + At(i), y: a })) : Xe(t) ? ((o = Ze(n = t)).top = o.top + n.clientTop, o.left = o.left + n.clientLeft, o.bottom = o.top + n.clientHeight, o.right = o.left + n.clientWidth, o.width = n.clientWidth, o.height = n.clientHeight, o.x = o.left, o.y = o.top, o) : Ct((s = E(e), r = E(s), i = wt(s), a = null == (a = s.ownerDocument) ? void 0 : a.body, t = O(r.scrollWidth, r.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), e = O(r.scrollHeight, r.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), s = -i.scrollLeft + At(s), i = -i.scrollTop, "rtl" === A(a || r).direction && (s += O(r.clientWidth, a ? a.clientWidth : 0) - t), { width: t, height: e, x: s, y: i })); var i, n, s, o, r, a } function xt(e) { var t, i = e.reference, n = e.element, s = (e = e.placement) ? N(e) : null, e = e ? dt(e) : null, o = i.x + i.width / 2 - n.width / 2, r = i.y + i.height / 2 - n.height / 2; switch (s) { case x: t = { x: o, y: i.y - n.height }; break; case k: t = { x: o, y: i.y + i.height }; break; case L: t = { x: i.x + i.width, y: r }; break; case D: t = { x: i.x - n.width, y: r }; break; default: t = { x: i.x, y: i.y } }var a = s ? ot(s) : null; if (null != a) { var l = "y" === a ? "height" : "width"; switch (e) { case I: t[a] = t[a] - (i[l] / 2 - n[l] / 2); break; case v: t[a] = t[a] + (i[l] / 2 - n[l] / 2) } } return t } function kt(e, t) { var n, i, s, o, r, a, l, c = void 0 === (c = (t = void 0 === t ? {} : t).placement) ? e.placement : c, h = void 0 === (h = t.boundary) ? He : h, d = void 0 === (d = t.rootBoundary) ? We : d, u = void 0 === (u = t.elementContext) ? _ : u, f = void 0 !== (f = t.altBoundary) && f, t = lt("number" != typeof (t = void 0 === (t = t.padding) ? 0 : t) ? t : ct(t, S)), p = e.rects.popper, f = e.elements[f ? u === _ ? Be : _ : u], f = (i = Xe(f) ? f : f.contextElement || E(e.elements.popper), o = d, a = "clippingParents" === (s = h) ? (l = Tt(it(a = i)), Xe(r = 0 <= ["absolute", "fixed"].indexOf(A(a).position) && w(a) ? st(a) : a) ? l.filter(function (e) { return Xe(e) && tt(e, r) && "body" !== b(e) }) : []) : [].concat(s), l = [].concat(a, [o]), s = l[0], (o = l.reduce(function (e, t) { return t = Ot(i, t), e.top = O(t.top, e.top), e.right = Ge(t.right, e.right), e.bottom = Ge(t.bottom, e.bottom), e.left = O(t.left, e.left), e }, Ot(i, s))).width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o), d = xt({ reference: h = Ze(e.elements.reference), element: p, strategy: "absolute", placement: c }), p = Ct(Object.assign({}, p, d)), g = { top: f.top - (d = u === _ ? p : h).top + t.top, bottom: d.bottom - f.bottom + t.bottom, left: f.left - d.left + t.left, right: d.right - f.right + t.right }, p = e.modifiersData.offset; return u === _ && p && (n = p[c], Object.keys(g).forEach(function (e) { var t = 0 <= [L, k].indexOf(e) ? 1 : -1, i = 0 <= [x, k].indexOf(e) ? "y" : "x"; g[e] += n[i] * t })), g } var Lt = { name: "flip", enabled: !0, phase: "main", fn: function (e) { var d = e.state, t = e.options, e = e.name; if (!d.modifiersData[e]._skip) { for (var i = void 0 === (s = t.mainAxis) || s, n = void 0 === (s = t.altAxis) || s, s = t.fallbackPlacements, u = t.padding, f = t.boundary, p = t.rootBoundary, o = t.altBoundary, r = t.flipVariations, g = void 0 === r || r, m = t.allowedAutoPlacements, t = N(r = d.options.placement), s = s || (t !== r && g ? N(s = r) === je ? [] : (t = bt(s), [yt(s), t, yt(t)]) : [bt(r)]), a = [r].concat(s).reduce(function (e, t) { return e.concat(N(t) === je ? (i = d, n = (e = { placement: t, boundary: f, rootBoundary: p, padding: u, flipVariations: g, allowedAutoPlacements: m }).placement, s = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = void 0 === (e = e.allowedAutoPlacements) ? ze : e, e = (c = dt(n)) ? a ? Fe : Fe.filter(function (e) { return dt(e) === c }) : S, h = (n = 0 === (n = e.filter(function (e) { return 0 <= l.indexOf(e) })).length ? e : n).reduce(function (e, t) { return e[t] = kt(i, { placement: t, boundary: s, rootBoundary: o, padding: r })[N(t)], e }, {}), Object.keys(h).sort(function (e, t) { return h[e] - h[t] })) : t); var i, n, s, o, r, a, l, c, h }, []), l = d.rects.reference, c = d.rects.popper, h = new Map, _ = !0, b = a[0], v = 0; v < a.length; v++) { var y = a[v], w = N(y), A = dt(y) === I, E = (C = 0 <= [x, k].indexOf(w)) ? "width" : "height", T = kt(d, { placement: y, boundary: f, rootBoundary: p, altBoundary: o, padding: u }), C = C ? A ? L : D : A ? k : x, A = (l[E] > c[E] && (C = bt(C)), bt(C)), E = []; if (i && E.push(T[w] <= 0), n && E.push(T[C] <= 0, T[A] <= 0), E.every(function (e) { return e })) { b = y, _ = !1; break } h.set(y, E) } if (_) for (var O = g ? 3 : 1; 0 < O && "break" !== function (t) { var e = a.find(function (e) { if (e = h.get(e)) return e.slice(0, t).every(function (e) { return e }) }); if (e) return b = e, "break" }(O); O--); d.placement !== b && (d.modifiersData[e]._skip = !0, d.placement = b, d.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function Dt(e, t, i) { return { top: e.top - t.height - (i = void 0 === i ? { x: 0, y: 0 } : i).y, right: e.right - t.width + i.x, bottom: e.bottom - t.height + i.y, left: e.left - t.width - i.x } } function St(t) { return [x, L, k, D].some(function (e) { return 0 <= t[e] }) } var It = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, e = e.name, i = t.rects.reference, n = t.rects.popper, s = t.modifiersData.preventOverflow, o = kt(t, { elementContext: "reference" }), r = kt(t, { altBoundary: !0 }), o = Dt(o, i), i = Dt(r, n, s), r = St(o), n = St(i); t.modifiersData[e] = { referenceClippingOffsets: o, popperEscapeOffsets: i, isReferenceHidden: r, hasPopperEscaped: n }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": r, "data-popper-escaped": n }) } }, Nt = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var r = e.state, t = e.options, e = e.name, a = void 0 === (t = t.offset) ? [0, 0] : t, i = (n = (t = ze.reduce(function (e, t) { var i, n, s, o; return e[t] = (i = r.rects, n = a, s = N(t), o = 0 <= [D, x].indexOf(s) ? -1 : 1, t = (i = "function" == typeof n ? n(Object.assign({}, i, { placement: t })) : n)[0] || 0, n = (i[1] || 0) * o, 0 <= [D, L].indexOf(s) ? { x: n, y: t } : { x: t, y: n }), e }, {}))[r.placement]).x, n = n.y; null != r.modifiersData.popperOffsets && (r.modifiersData.popperOffsets.x += i, r.modifiersData.popperOffsets.y += n), r.modifiersData[e] = t } }, Pt = { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, e = e.name; t.modifiersData[e] = xt({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, Mt = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t, i, n, s, o, r, a, l, c, h = e.state, d = e.options, e = e.name, u = void 0 === (u = d.mainAxis) || u, f = void 0 !== (f = d.altAxis) && f, p = d.boundary, g = d.rootBoundary, m = d.altBoundary, _ = d.padding, b = void 0 === (b = d.tether) || b, d = void 0 === (d = d.tetherOffset) ? 0 : d, p = kt(h, { boundary: p, rootBoundary: g, padding: _, altBoundary: m }), g = N(h.placement), m = !(_ = dt(h.placement)), v = ot(g), y = "x" === v ? "y" : "x", w = h.modifiersData.popperOffsets, A = h.rects.reference, E = h.rects.popper, d = "number" == typeof (d = "function" == typeof d ? d(Object.assign({}, h.rects, { placement: h.placement })) : d) ? { mainAxis: d, altAxis: d } : Object.assign({ mainAxis: 0, altAxis: 0 }, d), T = h.modifiersData.offset ? h.modifiersData.offset[h.placement] : null, C = { x: 0, y: 0 }; w && (u && (u = "y" === v ? "height" : "width", r = (a = w[v]) + p[i = "y" === v ? x : D], l = a - p[c = "y" === v ? k : L], t = b ? -E[u] / 2 : 0, s = (_ === I ? A : E)[u], _ = _ === I ? -E[u] : -A[u], o = h.elements.arrow, o = b && o ? et(o) : { width: 0, height: 0 }, i = (n = h.modifiersData["arrow#persistent"] ? h.modifiersData["arrow#persistent"].padding : at())[i], n = n[c], c = rt(0, A[u], o[u]), o = m ? A[u] / 2 - t - c - i - d.mainAxis : s - c - i - d.mainAxis, s = m ? -A[u] / 2 + t + c + n + d.mainAxis : _ + c + n + d.mainAxis, m = (i = h.elements.arrow && st(h.elements.arrow)) ? "y" === v ? i.clientTop || 0 : i.clientLeft || 0 : 0, _ = a + s - (t = null != (u = null == T ? void 0 : T[v]) ? u : 0), c = rt(b ? Ge(r, a + o - t - m) : r, a, b ? O(l, _) : l), w[v] = c, C[v] = c - a), f && (n = "y" == y ? "height" : "width", s = (i = w[y]) + p["x" === v ? x : D], u = i - p["x" === v ? k : L], o = -1 !== [x, D].indexOf(g), m = null != (t = null == T ? void 0 : T[y]) ? t : 0, r = o ? s : i - A[n] - E[n] - m + d.altAxis, _ = o ? i + A[n] + E[n] - m - d.altAxis : u, a = b && o ? (l = rt(l = r, i, c = _), c < l ? c : l) : rt(b ? r : s, i, b ? _ : u), w[y] = a, C[y] = a - i), h.modifiersData[e] = C) }, requiresIfExists: ["offset"] }; var jt = { placement: "bottom", modifiers: [], strategy: "absolute" }; function Ht() { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return !t.some(function (e) { return !(e && "function" == typeof e.getBoundingClientRect) }) } function Wt(e) { var t = (e = void 0 === e ? {} : e).defaultModifiers, d = void 0 === t ? [] : t, g = void 0 === (t = e.defaultOptions) ? jt : t; return function (a, l, t) { void 0 === t && (t = g); var i, n, u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, jt, g), modifiersData: {}, elements: { reference: a, popper: l }, attributes: {}, styles: {} }, c = [], f = !1, p = { state: u, setOptions: function (e) { var i, t, n, s, o, r, e = "function" == typeof e ? e(u.options) : e, e = (h(), u.options = Object.assign({}, g, u.options, e), u.scrollParents = { reference: Xe(a) ? Tt(a) : a.contextElement ? Tt(a.contextElement) : [], popper: Tt(l) }, e = [].concat(d, u.options.modifiers), t = e.reduce(function (e, t) { var i = e[t.name]; return e[t.name] = i ? Object.assign({}, i, t, { options: Object.assign({}, i.options, t.options), data: Object.assign({}, i.data, t.data) }) : t, e }, {}), e = Object.keys(t).map(function (e) { return t[e] }), n = e, s = new Map, o = new Set, r = [], n.forEach(function (e) { s.set(e.name, e) }), n.forEach(function (e) { o.has(e.name) || !function t(e) { o.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) { o.has(e) || (e = s.get(e)) && t(e) }), r.push(e) }(e) }), i = r, Qe.reduce(function (e, t) { return e.concat(i.filter(function (e) { return e.phase === t })) }, [])); return u.orderedModifiers = e.filter(function (e) { return e.enabled }), u.orderedModifiers.forEach(function (e) { var t = e.name, i = e.options; "function" == typeof (e = e.effect) && (e = e({ state: u, name: t, instance: p, options: void 0 === i ? {} : i }), c.push(e || function () { })) }), p.update() }, forceUpdate: function () { if (!f) { var e = u.elements, t = e.reference; if (Ht(t, e = e.popper)) { u.rects = { reference: (t = t, r = st(e), void 0 === (a = "fixed" === u.options.strategy) && (a = !1), l = w(r), c = w(r) && (d = (c = r).getBoundingClientRect(), h = Je(d.width) / c.offsetWidth || 1, d = Je(d.height) / c.offsetHeight || 1, 1 !== h || 1 !== d), h = E(r), d = Ze(t, c), t = { scrollLeft: 0, scrollTop: 0 }, c = { x: 0, y: 0 }, !l && a || ("body" === b(r) && !Et(h) || (t = (l = r) !== y(l) && w(l) ? { scrollLeft: l.scrollLeft, scrollTop: l.scrollTop } : wt(l)), w(r) ? ((c = Ze(r, !0)).x += r.clientLeft, c.y += r.clientTop) : h && (c.x = At(h))), { x: d.left + t.scrollLeft - c.x, y: d.top + t.scrollTop - c.y, width: d.width, height: d.height }), popper: et(e) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function (e) { return u.modifiersData[e.name] = Object.assign({}, e.data) }); for (var i, n, s, o = 0; o < u.orderedModifiers.length; o++)!0 === u.reset ? (u.reset = !1, o = -1) : (i = (s = u.orderedModifiers[o]).fn, n = s.options, s = s.name, "function" == typeof i && (u = i({ state: u, options: void 0 === n ? {} : n, name: s, instance: p }) || u)) } } var r, a, l, c, h, d }, update: (i = function () { return new Promise(function (e) { p.forceUpdate(), e(u) }) }, function () { return n = n || new Promise(function (e) { Promise.resolve().then(function () { n = void 0, e(i()) }) }) }), destroy: function () { h(), f = !0 } }; return Ht(a, l) && p.setOptions(t).then(function (e) { !f && t.onFirstUpdate && t.onFirstUpdate(e) }), p; function h() { c.forEach(function (e) { return e() }), c = [] } } } var Bt = Wt({ defaultModifiers: [mt, Pt, pt, Ue, Nt, Lt, Mt, ht, It] }); const Ft = Object.freeze(Object.defineProperty({ __proto__: null, popperGenerator: Wt, detectOverflow: kt, createPopperBase: Wt(), createPopper: Bt, createPopperLite: Wt({ defaultModifiers: [mt, Pt, pt, Ue] }), top: x, bottom: k, right: L, left: D, auto: je, basePlacements: S, start: I, end: v, clippingParents: He, viewport: We, popper: _, reference: Be, variationPlacements: Fe, placements: ze, beforeRead: Me, read: "read", afterRead: Re, beforeMain: qe, main: "main", afterMain: Ve, beforeWrite: $e, write: "write", afterWrite: Ke, modifierPhases: Qe, applyStyles: Ue, arrow: ht, computeStyles: pt, eventListeners: mt, flip: Lt, hide: It, offset: Nt, popperOffsets: Pt, preventOverflow: Mt }, Symbol.toStringTag, { value: "Module" })), zt = "dropdown", Rt = "ArrowDown", qt = (qe = "click" + (Me = ".bs.dropdown") + (Re = ".data-api"), Ve = "keydown" + Me + Re, "show"), Vt = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', $t = (Vt, ".dropdown-menu"), Kt = l() ? "top-end" : "top-start", Qt = l() ? "top-start" : "top-end", Xt = l() ? "bottom-end" : "bottom-start", Yt = l() ? "bottom-start" : "bottom-end", Ut = l() ? "left-start" : "right-start", Gt = l() ? "right-start" : "left-start", Jt = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: !0 }, Zt = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)" }; class T extends t { constructor(e, t) { super(e, t), this._popper = null, this._parent = this._element.parentNode, this._menu = u.findOne($t, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return Jt } static get DefaultType() { return Zt } static get NAME() { return zt } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (!a(this._element) && !this._isShown()) { var e = { relatedTarget: this._element }; if (!g.trigger(this._element, "show.bs.dropdown", e).defaultPrevented) { if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children)) g.on(t, "mouseover", z); this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(qt), this._element.classList.add(qt), g.trigger(this._element, "shown.bs.dropdown", e) } } } hide() { var e; !a(this._element) && this._isShown() && (e = { relatedTarget: this._element }, this._completeHide(e)) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(e) { if (!g.trigger(this._element, "hide.bs.dropdown", e).defaultPrevented) { if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) g.off(t, "mouseover", z); this._popper && this._popper.destroy(), this._menu.classList.remove(qt), this._element.classList.remove(qt), this._element.setAttribute("aria-expanded", "false"), d.removeDataAttribute(this._menu, "popper"), g.trigger(this._element, "hidden.bs.dropdown", e) } } _getConfig(e) { if ("object" != typeof (e = super._getConfig(e)).reference || o(e.reference) || "function" == typeof e.reference.getBoundingClientRect) return e; throw new TypeError(zt.toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.') } _createPopper() { if (void 0 === Ft) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; "parent" === this._config.reference ? e = this._parent : o(this._config.reference) ? e = n(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference); var t = this._getPopperConfig(); this._popper = Bt(e, this._menu, t) } _isShown() { return this._menu.classList.contains(qt) } _getPlacement() { var e, t = this._parent; return t.classList.contains("dropend") ? Ut : t.classList.contains("dropstart") ? Gt : t.classList.contains("dropup-center") ? "top" : t.classList.contains("dropdown-center") ? "bottom" : (e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(), t.classList.contains("dropup") ? e ? Qt : Kt : e ? Yt : Xt) } _detectNavbar() { return null !== this._element.closest(".navbar") } _getOffset() { const t = this._config.offset; return "string" == typeof t ? t.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof t ? e => t(e, this._element) : t } _getPopperConfig() { var e = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return !this._inNavbar && "static" !== this._config.display || (d.setDataAttribute(this._menu, "popper", "static"), e.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...e, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig } } _selectMenuItem({ key: e, target: t }) { var i = u.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(e => r(e)); i.length && K(i, t, e === Rt, !i.includes(t)).focus() } static jQueryInterface(t) { return this.each(function () { var e = T.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } }) } static clearMenus(e) { if (2 !== e.button && ("keyup" !== e.type || "Tab" === e.key)) for (const s of u.find('[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled).show')) { var t, i, n = T.getInstance(s); n && !1 !== n._config.autoClose && (t = (i = e.composedPath()).includes(n._menu), i.includes(n._element) || "inside" === n._config.autoClose && !t || "outside" === n._config.autoClose && t || n._menu.contains(e.target) && ("keyup" === e.type && "Tab" === e.key || /input|select|option|textarea|form/i.test(e.target.tagName)) || (i = { relatedTarget: n._element }, "click" === e.type && (i.clickEvent = e), n._completeHide(i))) } } static dataApiKeydownHandler(e) { var t = /input|textarea/i.test(e.target.tagName), i = "Escape" === e.key, n = ["ArrowUp", Rt].includes(e.key); !n && !i || t && !i || (e.preventDefault(), t = u.findOne(Vt, e.delegateTarget.parentNode), i = T.getOrCreateInstance(t), n ? (e.stopPropagation(), i.show(), i._selectMenuItem(e)) : i._isShown() && (e.stopPropagation(), i.hide(), t.focus())) } } g.on(document, Ve, Vt, T.dataApiKeydownHandler), g.on(document, Ve, $t, T.dataApiKeydownHandler), g.on(document, qe, T.clearMenus), g.on(document, "keyup.bs.dropdown.data-api", T.clearMenus), g.on(document, qe, Vt, function (e) { e.preventDefault(), T.getOrCreateInstance(this).toggle() }), e(T); const ei = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", ti = ".sticky-top", ii = "padding-right", ni = "margin-right"; class si { constructor() { this._element = document.body } getWidth() { var e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) } hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, ii, e => e + t), this._setElementAttributes(ei, ii, e => e + t), this._setElementAttributes(ti, ni, e => e - t) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, ii), this._resetElementAttributes(ei, ii), this._resetElementAttributes(ti, ni) } isOverflowing() { return 0 < this.getWidth() } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(e, i, n) { const s = this.getWidth(); this._applyManipulationCallback(e, e => { var t; e !== this._element && window.innerWidth > e.clientWidth + s || (this._saveInitialAttribute(e, i), t = window.getComputedStyle(e).getPropertyValue(i), e.style.setProperty(i, n(Number.parseFloat(t)) + "px")) }) } _saveInitialAttribute(e, t) { var i = e.style.getPropertyValue(t); i && d.setDataAttribute(e, t, i) } _resetElementAttributes(e, i) { this._applyManipulationCallback(e, e => { var t = d.getDataAttribute(e, i); null === t ? e.style.removeProperty(i) : (d.removeDataAttribute(e, i), e.style.setProperty(i, t)) }) } _applyManipulationCallback(e, t) { if (o(e)) t(e); else for (const i of u.find(e, this._element)) t(i) } } const oi = "backdrop", ri = "mousedown.bs." + oi, ai = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null }, li = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }; class ci extends he { constructor(e) { super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null } static get Default() { return ai } static get DefaultType() { return li } static get NAME() { return oi } show(e) { var t; this._config.isVisible ? (this._append(), t = this._getElement(), this._config.isAnimated && R(t), t.classList.add("show"), this._emulateAnimation(() => { c(e) })) : c(e) } hide(e) { this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => { this.dispose(), c(e) })) : c(e) } dispose() { this._isAppended && (g.off(this._element, ri), this._element.remove(), this._isAppended = !1) } _getElement() { var e; return this._element || ((e = document.createElement("div")).className = this._config.className, this._config.isAnimated && e.classList.add("fade"), this._element = e), this._element } _configAfterMerge(e) { return e.rootElement = n(e.rootElement), e } _append() { var e; this._isAppended || (e = this._getElement(), this._config.rootElement.append(e), g.on(e, ri, () => { c(this._config.clickCallback) }), this._isAppended = !0) } _emulateAnimation(e) { $(e, this._getElement(), this._config.isAnimated) } } const hi = ".bs.focustrap", di = (hi, hi, "backward"), ui = { trapElement: null, autofocus: !0 }, fi = { trapElement: "element", autofocus: "boolean" }; class pi extends he { constructor(e) { super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return ui } static get DefaultType() { return fi } static get NAME() { return "focustrap" } activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), g.off(document, hi), g.on(document, "focusin.bs.focustrap", e => this._handleFocusin(e)), g.on(document, "keydown.tab.bs.focustrap", e => this._handleKeydown(e)), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, g.off(document, hi)) } _handleFocusin(e) { var t = this._config.trapElement; e.target === document || e.target === t || t.contains(e.target) || (0 === (e = u.focusableChildren(t)).length ? t : this._lastTabNavDirection === di ? e[e.length - 1] : e[0]).focus() } _handleKeydown(e) { "Tab" === e.key && (this._lastTabNavDirection = e.shiftKey ? di : "forward") } } const C = ".bs.modal", gi = (C, C, "hidden" + C), mi = "show" + C, _i = (C, C, C, C, C, "modal-open"), bi = "modal-static", vi = { backdrop: !0, keyboard: !0, focus: !0 }, yi = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" }; class wi extends t { constructor(e, t) { super(e, t), this._dialog = u.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new si, this._addEventListeners() } static get Default() { return vi } static get DefaultType() { return yi } static get NAME() { return "modal" } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { this._isShown || this._isTransitioning || g.trigger(this._element, mi, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(_i), this._adjustDialog(), this._backdrop.show(() => this._showElement(e))) } hide() { !this._isShown || this._isTransitioning || g.trigger(this._element, "hide.bs.modal").defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove("show"), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())) } dispose() { for (const e of [window, this._dialog]) g.off(e, C); this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new ci({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new pi({ trapElement: this._element }) } _showElement(e) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0; var t = u.findOne(".modal-body", this._dialog); t && (t.scrollTop = 0), R(this._element), this._element.classList.add("show"), this._queueCallback(() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, g.trigger(this._element, "shown.bs.modal", { relatedTarget: e }) }, this._dialog, this._isAnimated()) } _addEventListeners() { g.on(this._element, "keydown.dismiss.bs.modal", e => { "Escape" === e.key && (this._config.keyboard ? (e.preventDefault(), this.hide()) : this._triggerBackdropTransition()) }), g.on(window, "resize.bs.modal", () => { this._isShown && !this._isTransitioning && this._adjustDialog() }), g.on(this._element, "click.dismiss.bs.modal", e => { e.target === e.currentTarget && ("static" === this._config.backdrop ? this._triggerBackdropTransition() : this._config.backdrop && this.hide()) }) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(_i), this._resetAdjustments(), this._scrollBar.reset(), g.trigger(this._element, gi) }) } _isAnimated() { return this._element.classList.contains("fade") } _triggerBackdropTransition() { var e; if (!g.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) { e = this._element.scrollHeight > document.documentElement.clientHeight; const t = this._element.style.overflowY; "hidden" === t || this._element.classList.contains(bi) || (e || (this._element.style.overflowY = "hidden"), this._element.classList.add(bi), this._queueCallback(() => { this._element.classList.remove(bi), this._queueCallback(() => { this._element.style.overflowY = t }, this._dialog) }, this._dialog), this._element.focus()) } } _adjustDialog() { var e, t = this._element.scrollHeight > document.documentElement.clientHeight, i = this._scrollBar.getWidth(), n = 0 < i; n && !t && (e = l() ? "paddingLeft" : "paddingRight", this._element.style[e] = i + "px"), !n && t && (e = l() ? "paddingRight" : "paddingLeft", this._element.style[e] = i + "px") } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(t, i) { return this.each(function () { var e = wi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](i) } }) } } g.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', function (e) { const t = s(this);["A", "AREA"].includes(this.tagName) && e.preventDefault(), g.one(t, mi, e => { e.defaultPrevented || g.one(t, gi, () => { r(this) && this.focus() }) }), (e = u.findOne(".modal.show")) && wi.getInstance(e).hide(), wi.getOrCreateInstance(t).toggle(this) }), de(wi), e(wi); const Ai = "showing", Ei = ".offcanvas.show", Ti = "hidePrevented" + ($e = ".bs.offcanvas"), Ci = "hidden" + $e, Oi = { backdrop: !0, keyboard: !0, scroll: !1 }, xi = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }; class P extends t { constructor(e, t) { super(e, t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return Oi } static get DefaultType() { return xi } static get NAME() { return "offcanvas" } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { this._isShown || g.trigger(this._element, "show.bs.offcanvas", { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new si).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Ai), this._queueCallback(() => { this._config.scroll || this._focustrap.activate(), this._element.classList.add("show"), this._element.classList.remove(Ai), g.trigger(this._element, "shown.bs.offcanvas", { relatedTarget: e }) }, this._element, !0)) } hide() { this._isShown && !g.trigger(this._element, "hide.bs.offcanvas").defaultPrevented && (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add("hiding"), this._backdrop.hide(), this._queueCallback(() => { this._element.classList.remove("show", "hiding"), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new si).reset(), g.trigger(this._element, Ci) }, this._element, !0)) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _initializeBackDrop() { var e = Boolean(this._config.backdrop); return new ci({ className: "offcanvas-backdrop", isVisible: e, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: e ? () => { "static" === this._config.backdrop ? g.trigger(this._element, Ti) : this.hide() } : null }) } _initializeFocusTrap() { return new pi({ trapElement: this._element }) } _addEventListeners() { g.on(this._element, "keydown.dismiss.bs.offcanvas", e => { "Escape" === e.key && (this._config.keyboard ? this.hide() : g.trigger(this._element, Ti)) }) } static jQueryInterface(t) { return this.each(function () { var e = P.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } }) } } g.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function (e) { var t = s(this);["A", "AREA"].includes(this.tagName) && e.preventDefault(), a(this) || (g.one(t, Ci, () => { r(this) && this.focus() }), (e = u.findOne(Ei)) && e !== t && P.getInstance(e).hide(), P.getOrCreateInstance(t).toggle(this)) }), g.on(window, "load.bs.offcanvas.data-api", () => { for (const e of u.find(Ei)) P.getOrCreateInstance(e).show() }), g.on(window, "resize.bs.offcanvas", () => { for (const e of u.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(e).position && P.getOrCreateInstance(e).hide() }), de(P), e(P); const ki = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Li = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Di = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; const Si = { extraClass: "", template: "<div></div>", content: {}, html: !(Ke = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }), sanitize: !0, sanitizeFn: null, allowList: Ke }, Ii = { extraClass: "(string|function)", template: "string", content: "object", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object" }, Ni = { selector: "(string|element)", entry: "(string|element|function|null)" }; class Pi extends he { constructor(e) { super(), this._config = this._getConfig(e) } static get Default() { return Si } static get DefaultType() { return Ii } static get NAME() { return "TemplateFactory" } getContent() { return Object.values(this._config.content).map(e => this._resolvePossibleFunction(e)).filter(Boolean) } hasContent() { return 0 < this.getContent().length } changeContent(e) { return this._checkContent(e), this._config.content = { ...this._config.content, ...e }, this } toHtml() { var e, t, i = document.createElement("div"); i.innerHTML = this._maybeSanitize(this._config.template); for ([e, t] of Object.entries(this._config.content)) this._setContent(i, t, e); var n = i.children[0], s = this._resolvePossibleFunction(this._config.extraClass); return s && n.classList.add(...s.split(" ")), n } _typeCheckConfig(e) { super._typeCheckConfig(e), this._checkContent(e.content) } _checkContent(e) { for (var [t, i] of Object.entries(e)) super._typeCheckConfig({ selector: t, entry: i }, Ni) } _setContent(e, t, i) { (i = u.findOne(i, e)) && ((t = this._resolvePossibleFunction(t)) ? o(t) ? this._putElementInTemplate(n(t), i) : this._config.html ? i.innerHTML = this._maybeSanitize(t) : i.textContent = t : i.remove()) } _maybeSanitize(e) { if (this._config.sanitize) { var t = e, i = this._config.allowList, n = this._config.sanitizeFn; if (!t.length) return t; if (n && "function" == typeof n) return n(t); n = (new window.DOMParser).parseFromString(t, "text/html"); for (const a of [].concat(...n.body.querySelectorAll("*"))) { var s = a.nodeName.toLowerCase(); if (Object.keys(i).includes(s)) { var o = [].concat(...a.attributes), r = [].concat(i["*"] || [], i[s] || []); for (const l of o) ((e, t) => { const i = e.nodeName.toLowerCase(); return t.includes(i) ? !ki.has(i) || Boolean(Li.test(e.nodeValue) || Di.test(e.nodeValue)) : t.filter(e => e instanceof RegExp).some(e => e.test(i)) })(l, r) || a.removeAttribute(l.nodeName) } else a.remove() } return n.body.innerHTML } return e } _resolvePossibleFunction(e) { return "function" == typeof e ? e(this) : e } _putElementInTemplate(e, t) { this._config.html ? (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent } } const Mi = new Set(["sanitize", "allowList", "sanitizeFn"]), ji = "fade", Hi = "show", Wi = "hide.bs.modal", Bi = "hover", Fi = "focus", zi = { AUTO: "auto", TOP: "top", RIGHT: l() ? "left" : "right", BOTTOM: "bottom", LEFT: l() ? "right" : "left" }, Ri = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, selector: !1, placement: "top", offset: [0, 0], container: !1, fallbackPlacements: ["top", "right", "bottom", "left"], boundary: "clippingParents", customClass: "", sanitize: !0, sanitizeFn: null, allowList: Ke, popperConfig: null }, qi = { animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", offset: "(array|string|function)", container: "(string|element|boolean)", fallbackPlacements: "array", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object|function)" }; class Vi extends t { constructor(e, t) { if (void 0 === Ft) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e, t), this._isEnabled = !0, this._timeout = 0, this._isHovered = !1, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this.tip = null, this._setListeners() } static get Default() { return Ri } static get DefaultType() { return qi } static get NAME() { return "tooltip" } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle(e) { this._isEnabled && (e ? ((e = this._initializeOnDelegatedTarget(e))._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter() : e._leave()) : this._isShown() ? this._leave() : this._enter()) } dispose() { clearTimeout(this._timeout), g.off(this._element.closest(".modal"), Wi, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose() } show() { if ("none" === this._element.style.display) throw new Error("Please use show on visible elements"); if (this._isWithContent() && this._isEnabled) { var e = g.trigger(this._element, this.constructor.eventName("show")), t = (F(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (!e.defaultPrevented && t) { if (e = this._getTipElement(), this._element.setAttribute("aria-describedby", e.getAttribute("id")), t = this._config.container, this._element.ownerDocument.documentElement.contains(this.tip) || (t.append(e), g.trigger(this._element, this.constructor.eventName("inserted"))), this._popper ? this._popper.update() : this._createPopper(e), e.classList.add(Hi), "ontouchstart" in document.documentElement) for (const i of [].concat(...document.body.children)) g.on(i, "mouseover", z); this._queueCallback(() => { var e = this._isHovered; this._isHovered = !1, g.trigger(this._element, this.constructor.eventName("shown")), e && this._leave() }, this.tip, this._isAnimated()) } } } hide() { if (this._isShown() && !g.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) { const e = this._getTipElement(); if (e.classList.remove(Hi), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) g.off(t, "mouseover", z); this._activeTrigger.click = !1, this._activeTrigger[Fi] = !1, this._activeTrigger[Bi] = !1, this._isHovered = !1, this._queueCallback(() => { this._isWithActiveTrigger() || (this._isHovered || e.remove(), this._element.removeAttribute("aria-describedby"), g.trigger(this._element, this.constructor.eventName("hidden")), this._disposePopper()) }, this.tip, this._isAnimated()) } } update() { this._popper && this._popper.update() } _isWithContent() { return Boolean(this._getTitle()) } _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._getContentForTemplate())), this.tip } _createTipElement(e) { if (!(e = this._getTemplateFactory(e).toHtml())) return null; e.classList.remove(ji, Hi), e.classList.add(`bs-${this.constructor.NAME}-auto`); var t = (e => { for (; e += Math.floor(1e6 * Math.random()), document.getElementById(e);); return e })(this.constructor.NAME).toString(); return e.setAttribute("id", t), this._isAnimated() && e.classList.add(ji), e } setContent(e) { let t = !1; this.tip && (t = this._isShown(), this.tip.remove(), this.tip = null), this._disposePopper(), this.tip = this._createTipElement(e), t && this.show() } _getTemplateFactory(e) { return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new Pi({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory } _getContentForTemplate() { return { ".tooltip-inner": this._getTitle() } } _getTitle() { return this._config.title } _initializeOnDelegatedTarget(e) { return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()) } _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(ji) } _isShown() { return this.tip && this.tip.classList.contains(Hi) } _createPopper(e) { var t = "function" == typeof this._config.placement ? this._config.placement.call(this, e, this._element) : this._config.placement, t = zi[t.toUpperCase()]; this._popper = Bt(this._element, e, this._getPopperConfig(t)) } _getOffset() { const t = this._config.offset; return "string" == typeof t ? t.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof t ? e => t(e, this._element) : t } _resolvePossibleFunction(e) { return "function" == typeof e ? e.call(this._element) : e } _getPopperConfig(e) { return { ...e = { placement: e, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: e => { this._getTipElement().setAttribute("data-popper-placement", e.state.placement) } }] }, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig } } _setListeners() { var e, t; for (const i of this._config.trigger.split(" ")) "click" === i ? g.on(this._element, this.constructor.eventName("click"), this._config.selector, e => this.toggle(e)) : "manual" !== i && (e = i === Bi ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), t = i === Bi ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout"), g.on(this._element, e, this._config.selector, e => { var t = this._initializeOnDelegatedTarget(e); t._activeTrigger["focusin" === e.type ? Fi : Bi] = !0, t._enter() }), g.on(this._element, t, this._config.selector, e => { var t = this._initializeOnDelegatedTarget(e); t._activeTrigger["focusout" === e.type ? Fi : Bi] = t._element.contains(e.relatedTarget), t._leave() })); this._hideModalHandler = () => { this._element && this.hide() }, g.on(this._element.closest(".modal"), Wi, this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle() } _fixTitle() { var e = this._config.originalTitle; e && (this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", e), this._element.removeAttribute("title")) } _enter() { this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => { this._isHovered && this.show() }, this._config.delay.show)) } _leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => { this._isHovered || this.hide() }, this._config.delay.hide)) } _setTimeout(e, t) { clearTimeout(this._timeout), this._timeout = setTimeout(e, t) } _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) } _getConfig(e) { var t = d.getDataAttributes(this._element); for (const i of Object.keys(t)) Mi.has(i) && delete t[i]; return e = { ...t, ..."object" == typeof e && e ? e : {} }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e.container = !1 === e.container ? document.body : n(e.container), "number" == typeof e.delay && (e.delay = { show: e.delay, hide: e.delay }), e.originalTitle = this._element.getAttribute("title") || "", e.title = this._resolvePossibleFunction(e.title) || e.originalTitle, "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), e } _getDelegateConfig() { var e = {}; for (const t in this._config) this.constructor.Default[t] !== this._config[t] && (e[t] = this._config[t]); return e } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null) } static jQueryInterface(t) { return this.each(function () { var e = Vi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } }) } } e(Vi); const $i = { ...Vi.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }, Ki = { ...Vi.DefaultType, content: "(null|string|element|function)" }; class Qi extends Vi { static get Default() { return $i } static get DefaultType() { return Ki } static get NAME() { return "popover" } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(t) { return this.each(function () { var e = Qi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } }) } } e(Qi); const Xi = "click" + ".bs.scrollspy", Yi = "active", Ui = "[href]", Gi = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null }, Ji = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element" }; class Zi extends t { constructor(e, t) { super(e, t), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return Gi } static get DefaultType() { return Ji } static get NAME() { return "scrollspy" } refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const e of this._observableSections.values()) this._observer.observe(e) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(e) { return e.target = n(e.target) || document.body, e } _maybeEnableSmoothScroll() { this._config.smoothScroll && (g.off(this._config.target, Xi), g.on(this._config.target, Xi, Ui, e => { var t = this._observableSections.get(e.target.hash); t && (e.preventDefault(), e = this._rootElement || window, t = t.offsetTop - this._element.offsetTop, e.scrollTo ? e.scrollTo({ top: t }) : e.scrollTop = t) })) } _getNewObserver() { var e = { root: this._rootElement, threshold: [.1, .5, 1], rootMargin: this._getRootMargin() }; return new IntersectionObserver(e => this._observerCallback(e), e) } _observerCallback(e) { const t = e => this._targetLinks.get("#" + e.target.id); var i = e => { this._previousScrollData.visibleEntryTop = e.target.offsetTop, this._process(t(e)) }, n = (this._rootElement || document.documentElement).scrollTop, s = n >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = n; for (const r of e) if (r.isIntersecting) { var o = r.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (s && o) { if (i(r), n) continue; return } s || o || i(r) } else this._activeTarget = null, this._clearActiveClass(t(r)) } _getRootMargin() { return this._config.offset ? this._config.offset + "px 0px -30%" : this._config.rootMargin } _initializeTargetsAndObservables() { var e; this._targetLinks = new Map, this._observableSections = new Map; for (const t of u.find(Ui, this._config.target)) t.hash && !a(t) && (e = u.findOne(t.hash, this._element), r(e)) && (this._targetLinks.set(t.hash, t), this._observableSections.set(t.hash, e)) } _process(e) { this._activeTarget !== e && (this._clearActiveClass(this._config.target), (this._activeTarget = e).classList.add(Yi), this._activateParents(e), g.trigger(this._element, "activate.bs.scrollspy", { relatedTarget: e })) } _activateParents(e) { if (e.classList.contains("dropdown-item")) u.findOne(".dropdown-toggle", e.closest(".dropdown")).classList.add(Yi); else for (const t of u.parents(e, ".nav, .list-group")) for (const i of u.prev(t, ".nav-link, .nav-item > .nav-link, .list-group-item")) i.classList.add(Yi) } _clearActiveClass(e) { e.classList.remove(Yi); for (const t of u.find(Ui + "." + Yi, e)) t.classList.remove(Yi) } static jQueryInterface(t) { return this.each(function () { var e = Zi.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } }) } } g.on(window, "load.bs.scrollspy.data-api", () => { for (const e of u.find('[data-bs-spy="scroll"]')) Zi.getOrCreateInstance(e) }), e(Zi); const en = "ArrowRight", tn = "ArrowDown", M = "active", nn = "show", sn = '.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ' + (ht = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'); M, M, M; class on extends t { constructor(e) { super(e), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), g.on(this._element, "keydown.bs.tab", e => this._keydown(e))) } static get NAME() { return "tab" } show() { var e, t, i = this._element; this._elemIsActive(i) || (t = (e = this._getActiveElem()) ? g.trigger(e, "hide.bs.tab", { relatedTarget: i }) : null, g.trigger(i, "show.bs.tab", { relatedTarget: e }).defaultPrevented) || t && t.defaultPrevented || (this._deactivate(e, i), this._activate(i, e)) } _activate(e, t) { if (e) { e.classList.add(M), this._activate(s(e)); const i = e.classList.contains("fade"); this._queueCallback(() => { i && e.classList.add(nn), "tab" === e.getAttribute("role") && (e.focus(), e.removeAttribute("tabindex"), e.setAttribute("aria-selected", !0), this._toggleDropDown(e, !0), g.trigger(e, "shown.bs.tab", { relatedTarget: t })) }, e, i) } } _deactivate(e, t) { if (e) { e.classList.remove(M), e.blur(), this._deactivate(s(e)); const i = e.classList.contains("fade"); this._queueCallback(() => { i && e.classList.remove(nn), "tab" === e.getAttribute("role") && (e.setAttribute("aria-selected", !1), e.setAttribute("tabindex", "-1"), this._toggleDropDown(e, !1), g.trigger(e, "hidden.bs.tab", { relatedTarget: t })) }, e, i) } } _keydown(e) { var t;["ArrowLeft", en, "ArrowUp", tn].includes(e.key) && (e.stopPropagation(), e.preventDefault(), t = [en, tn].includes(e.key), e = K(this._getChildren().filter(e => !a(e)), e.target, t, !0)) && on.getOrCreateInstance(e).show() } _getChildren() { return u.find(sn, this._parent) } _getActiveElem() { return this._getChildren().find(e => this._elemIsActive(e)) || null } _setInitialAttributes(e, t) { this._setAttributeIfNotExists(e, "role", "tablist"); for (const i of t) this._setInitialAttributesOnChild(i) } _setInitialAttributesOnChild(e) { e = this._getInnerElement(e); var t = this._elemIsActive(e), i = this._getOuterElement(e); e.setAttribute("aria-selected", t), i !== e && this._setAttributeIfNotExists(i, "role", "presentation"), t || e.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e, "role", "tab"), this._setInitialAttributesOnTargetPanel(e) } _setInitialAttributesOnTargetPanel(e) { var t = s(e); t && (this._setAttributeIfNotExists(t, "role", "tabpanel"), e.id) && this._setAttributeIfNotExists(t, "aria-labelledby", "#" + e.id) } _toggleDropDown(e, i) { const n = this._getOuterElement(e); n.classList.contains("dropdown") && ((e = (e, t) => { (e = u.findOne(e, n)) && e.classList.toggle(t, i) })(".dropdown-toggle", M), e(".dropdown-menu", nn), e(".dropdown-item", M), n.setAttribute("aria-expanded", i)) } _setAttributeIfNotExists(e, t, i) { e.hasAttribute(t) || e.setAttribute(t, i) } _elemIsActive(e) { return e.classList.contains(M) } _getInnerElement(e) { return e.matches(sn) ? e : u.findOne(sn, e) } _getOuterElement(e) { return e.closest(".nav-item, .list-group-item") || e } static jQueryInterface(t) { return this.each(function () { var e = on.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t]() } }) } } g.on(document, "click.bs.tab", ht, function (e) { ["A", "AREA"].includes(this.tagName) && e.preventDefault(), a(this) || on.getOrCreateInstance(this).show() }), g.on(window, "load.bs.tab", () => { for (const e of u.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]')) on.getOrCreateInstance(e) }), e(on); const rn = "show", an = "showing", ln = { animation: "boolean", autohide: "boolean", delay: "number" }, cn = { animation: !0, autohide: !0, delay: 5e3 }; class hn extends t { constructor(e, t) { super(e, t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return cn } static get DefaultType() { return ln } static get NAME() { return "toast" } show() { g.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), R(this._element), this._element.classList.add(rn, an), this._queueCallback(() => { this._element.classList.remove(an), g.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide() }, this._element, this._config.animation)) } hide() { this.isShown() && !g.trigger(this._element, "hide.bs.toast").defaultPrevented && (this._element.classList.add(an), this._queueCallback(() => { this._element.classList.add("hide"), this._element.classList.remove(an, rn), g.trigger(this._element, "hidden.bs.toast") }, this._element, this._config.animation)) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(rn), super.dispose() } isShown() { return this._element.classList.contains(rn) } _maybeScheduleHide() { !this._config.autohide || this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay)) } _onInteraction(e, t) { switch (e.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = t; break; case "focusin": case "focusout": this._hasKeyboardInteraction = t }t ? this._clearTimeout() : (e = e.relatedTarget, this._element === e || this._element.contains(e) || this._maybeScheduleHide()) } _setListeners() { g.on(this._element, "mouseover.bs.toast", e => this._onInteraction(e, !0)), g.on(this._element, "mouseout.bs.toast", e => this._onInteraction(e, !1)), g.on(this._element, "focusin.bs.toast", e => this._onInteraction(e, !0)), g.on(this._element, "focusout.bs.toast", e => this._onInteraction(e, !1)) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each(function () { var e = hn.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this) } }) } } return de(hn), e(hn), { Alert: ue, Button: pe, Carousel: ke, Collapse: Pe, Dropdown: T, Modal: wi, Offcanvas: P, Popover: Qi, ScrollSpy: Zi, Tab: on, Toast: hn, Tooltip: Vi } });